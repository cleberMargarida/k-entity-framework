//using Microsoft.CodeAnalysis;
//using Microsoft.CodeAnalysis.CSharp.Syntax;
//using System.Collections.Generic;
//using System.Diagnostics;
//using System.Linq;
//using System.Text;

//namespace DotKafka.CodeAnalysis;

//[Generator]
//public class KafkaFacadeEventGenericExtensionGenerator : IIncrementalGenerator
//{
//    public void Initialize(IncrementalGeneratorInitializationContext context)
//    {
//        var candidateClasses = context.SyntaxProvider
//            .CreateSyntaxProvider(
//                predicate: static (node, _) => node is ClassDeclarationSyntax,
//                transform: static (ctx, _) => GetClassIfKafkaFacadeDerived(ctx))
//            .Where(static symbol => symbol is not null);

//        var compilationAndClasses = context.CompilationProvider.Combine(candidateClasses.Collect());

//        context.RegisterSourceOutput(compilationAndClasses, (spc, source) =>
//        {
//            Generate(source.Left, source.Right!, spc);
//        });
//    }

//    private static INamedTypeSymbol? GetClassIfKafkaFacadeDerived(GeneratorSyntaxContext context)
//    {
//        var kafkaFacadeBase = context.SemanticModel.Compilation.GetTypeByMetadataName("DotKafka.KafkaFacade");

//        if (context.Node is not ClassDeclarationSyntax classDecl)
//            return null;

//        if (context.SemanticModel.GetDeclaredSymbol(classDecl) is not INamedTypeSymbol classSymbol)
//            return null;

//        if (IsDerivedFromKafkaFacade(classSymbol, kafkaFacadeBase))
//            return classSymbol;

//        return null;
//    }

//    private static bool IsDerivedFromKafkaFacade(INamedTypeSymbol? symbol, INamedTypeSymbol? kafkaFacadeBase)
//    {
//        while (symbol != null)
//        {
//            if (symbol.BaseType?.Equals(kafkaFacadeBase, SymbolEqualityComparer.Default) is true)
//                return true;

//            symbol = symbol.BaseType;
//        }
//        return false;
//    }

//    private static void Generate(Compilation compilation, IEnumerable<INamedTypeSymbol> classes, SourceProductionContext context)
//    {
//        foreach (var classSymbol in classes)
//        {
//            var namespaceName = classSymbol.ContainingNamespace.IsGlobalNamespace
//                ? null
//                : classSymbol.ContainingNamespace.ToDisplayString();

//            var className = classSymbol.Name;

//            var source = GenerateExtensionSource(namespaceName, className);
//            context.AddSource($"{className}_EventModelBuilderExtensions.g.cs", source);
//        }
//    }

//    private static string GenerateExtensionSource(string? namespaceName, string className)
//    {
//        var sb = new StringBuilder();

//        sb.AppendLine("// <auto-generated />");
//        sb.AppendLine("using System;");
//        sb.AppendLine("using System.Linq.Expressions;");
//        sb.AppendLine();

//        if (!string.IsNullOrEmpty(namespaceName))
//        {
//            sb.AppendLine($"namespace {namespaceName}");
//            sb.AppendLine("{");
//        }

//        sb.AppendLine($"    public static class EventModelBuilderExtensionsFor{className}");
//        sb.AppendLine("    {");
//        sb.AppendLine($"        public static DotKafka.EventTypeBuilder<TEvent> Event<TProp, TEvent>(");
//        sb.AppendLine("            this DotKafka.EventModelBuilder model,");
//        sb.AppendLine($"            Expression<Func<{className}, TProp>> topic)");
//        sb.AppendLine("            where TProp : DotKafka.Topic<TEvent>");
//        sb.AppendLine("        {");
//        sb.AppendLine("            return model.Event<TEvent>();");
//        sb.AppendLine("        }");
//        sb.AppendLine("    }");

//        if (!string.IsNullOrEmpty(namespaceName))
//        {
//            sb.AppendLine("}");
//        }

//        return sb.ToString();
//    }
//}